#!/bin/bash
junit_version=6.0.1
app_name=$1
# create project folder structure
mkdir -p ${app_name}/{src/{docs,{main,test}/{java,resources/i18n}},libs}
# Add the README file
cat <<EOL > ${app_name}/README.md
# README

This is the readme file for the project ${app_name}

That's all folks !
EOL
# Add the internationalisation file
cat <<EOL > ${app_name}/src/main/resources/i18n/messages.properties
app.name=${app_name}
app.version=0.0.1
app.language=English
EOL
# Add the configuration file
cat <<EOL > ${app_name}/src/main/resources/config.properties
app.debug=0
app.mode=PROD
EOL
# Add .gitignore
echo """
target/
*.class
*.jar
*.war
*.ear
*.db
*.log
*.tmp
*.swp
*.swo
""" > ${app_name}/.gitignore
# Add main class
mkdir -p "${app_name}/src/main/java/core"
CAT <<EOL > "${app_name}/src/main/java/core/App.java"
package core;

import java.io.IOException;
import java.time.ZonedDateTime;
import java.util.Locale;
import java.util.Properties;
import java.util.ResourceBundle;

public class App {

  public enum Mode {
    DEV, TEST, PROD;
  }

  public enum LogLevel {
    DEBUG, INFO, WARN, ERROR, FATAL;
  }

  private static final ResourceBundle messages = ResourceBundle.getBundle("i18n/messages", Locale.ROOT);
  private static final Properties config = new Properties();
  private static String configFileName = "config.properties";

  private static int debug = 0;
  private Mode mode = Mode.PROD;

  public App() {
    info(App.class, "%s (%s)".formatted(
        messages.getString("app.name"),
        messages.getString("app.version")));
    debug(App.class, 0, "Language: %s".formatted(messages.getString("app.language")));
    info(App.class, "Starts...");

  }

  public void run(String[] args) {
    initConfig();
    parseArguments(args);
    configFileName = config.getProperty("configFileName");
    loadConfig(configFileName);
    parseArguments(args);
    parseConfig();
    info(App.class, "End.");
  }

  private void initConfig() {
    // set default values
    config.setProperty("app.debug", "0");
    config.setProperty("app.mode", "PROD");
    config.setProperty("configFileName", "/config.properties");
  }

  private void loadConfig(String fileName) {
    // load values from configuration file
    try {
      config.load(this.getClass().getResourceAsStream(fileName));
      // extract values
    } catch (IOException e) {
      error(App.class, "Unable to read configuration from file '%s' : %s%n", fileName, e.getMessage());
    }
  }

  private void parseConfig() {
    for (String key : config.stringPropertyNames()) {
      switch (key) {
        case "configFileName", "cfg" -> {
          configFileName = config.getProperty(key);
          info(App.class, "- configFileName: %s", configFileName);
        }
        case "app.debug", "debug", "d" -> {
          int debug = Integer.parseInt(config.getProperty(key));
          info(App.class, "- debug: %d", debug);
        }
        case "app.mode", "mode", "m" -> {
          this.mode = Mode.valueOf(config.getProperty(key).toUpperCase());
          info(App.class, "- mode: %s", mode);
        }
        default -> {
          info(App.class, "Unknown config key: %s", key);
        }
      }
    }
  }

  private void parseArguments(String[] args) {
    for (String arg : args) {
      if (arg.contains("=")) {
        String[] keyValue = arg.split("=", 2);
        String key = keyValue[0];
        String value = keyValue[1];
        config.setProperty(key, value);
        info(App.class, "Set config %s=%s from command-line argument", key, value);
      }
    }
  }

  public static void main(String[] args) {
    App app = new App();
    app.run(args);
  }

  public static boolean isDebugGreaterThan(int i) {
    return debug > i;
  }

  /** ---- Logging API ---- ***/

  private static void log(Class<?> className, LogLevel level, String message, Object... args) {
    if (level == LogLevel.ERROR || level == LogLevel.FATAL) {
      System.err.printf("%s;%s;[%s];%s%n", ZonedDateTime.now(), level, className.getName(), message.formatted(args));
      return;
    }
    System.out.printf("%s;%s;[%s];%s%n", ZonedDateTime.now(), level, className.getName(), message.formatted(args));
  }

  public static void debug(Class<?> className, int debugLevel, String message, Object... args) {
    if (debug > debugLevel) {
      log(className, LogLevel.DEBUG, message, args);
    }
  }

  public static void info(Class<?> className, String message, Object... args) {
    log(className, LogLevel.INFO, message, args);
  }

  public static void warn(Class<?> className, String message, Object... args) {
    log(className, LogLevel.WARN, message, args);
  }

  public static void error(Class<?> className, String message, Object... args) {
    log(className, LogLevel.ERROR, message, args);
  }

  public static void fatal(Class<?> className, int errorLevel, String message, Object... args) {
    log(className, LogLevel.FATAL, message, args);
    System.exit(errorLevel);
  }
}
EOL
# VS Code integration
mkdir -p ${app_name}/.vscode
cat <<EOL > ${app_name}/.vscode/settings.json
{
    "java.format.settings.url": ".vscode/java-formatter.xml",
    "java.project.sourcePaths": [
        "src/main/java",
        "src/main/resources",
        "src/test/java",
        "src/test/resources"
    ],
    "java.project.encoding": "warning",
    "java.project.referencedLibraries": [],
    "java.project.outputPath": "target/classes"
}
EOL
cp ~/scripts/scripts-library/java-formatter.xml ${app_name}/.vscode/java-formatter.xml

# Add docs
app_name=${app_name}
cat <<EOL > "${app_name}/src/docs/00-preface.md"
# Project ${app_name}

## Preface

This is the preface for the documentation of the project ${app_name}.
You must rewrite this document according to your specifications.

>[!NOTE]
>Please us the markdown text format to easily create
>docs in multiple format with the 'pandoc' tool.
EOL
# Add build script

cp ~/scripts/templates/build_micro.txt ${app_name}/build
# Add junit library
curl -sL https://repo1.maven.org/maven2/org/junit/platform/junit-platform-console-standalone/${junit_version}/junit-platform-console-standalone-${junit_version}.jar >${app_name}/libs/junit-platform-console-standalone-${junit_version}.jar
# create local git repository
cd ${app_name}
git init --initial-branch=main
git -C "${app_name}" add .
git -C "${app_name}" commit -m "Create the project '${app_name}'"
echo "Project '${app_name}' created."
